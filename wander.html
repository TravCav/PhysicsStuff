<html>

<head>
	<style>
		body {
			background-color: #000000;
			margin: 0px;
		}

		canvas,
		img {
			image-rendering: optimizeSpeed;
			image-rendering: -moz-crisp-edges;
			image-rendering: -webkit-optimize-contrast;
			image-rendering: optimize-contrast;
			-ms-interpolation-mode: nearest-neighbor;
		}
	</style>
	<title>stuff</title>
</head>

<body>
	<canvas id="gridCanvas" width="1000" height="1000"></canvas>
	<script type="text/javascript">
		var cvs = document.getElementById('gridCanvas')
		var ctx = cvs.getContext('2d');

		ctx.canvas.width = window.innerWidth;
		ctx.canvas.height = window.innerHeight;
		var centerX = ctx.canvas.width / 2;
		var centerY = ctx.canvas.height / 2;
		var pixels;
		var dotCount = 100;
		var friction = 1;//.025;
		var kick = 0;
		var halfKick = kick / 2;
		var gravity = 1;

		function Color(r, g, b, a) {
			this.r = r || 255;
			this.g = g || 255;
			this.b = b || 255;
			this.a = a || 255;
		}

		function Point(x, y) {
			this.x = x || 0;
			this.y = y || 0;
		}

		function Dot(x, y, m) {
			var self = this;
			self.x = x || Math.floor(Math.random() * ctx.canvas.width);
			self.y = y || Math.floor(Math.random() * ctx.canvas.height);
			self.color = new Color();

			self.vector = new Point(0,0);
			self.mass = m || 1;

			this.neurons = [];
			this.Init();
		}

		Dot.prototype.Init = function (){
			let neuronCount = 4;
			for (let index = 0; index < neuronCount; index++) {
				this.neurons.push(new neuron(neuronCount));				
			}
		}

		Dot.prototype.Think = function(){
			let newValues = [0,0,0,0];

			 for (let index = 0; index < this.neurons.length; index++) {
				for (let cindex = 0; cindex < this.neurons[index].connections.length; cindex++) {
					newValues[index] += (this.neurons[cindex].value * this.neurons[index].connections[cindex].weight) + this.neurons[index].bias;
				}
			 }			

			for (let index = 0; index < this.neurons.length; index++) {
				this.neurons[index].value = newValues[index];
			}		
		}

		Dot.prototype.Wrap = function () {
			if (this.x > ctx.canvas.width) { this.x = 0; }
			if (this.x < 0) { this.x = ctx.canvas.width; }
			if (this.y > ctx.canvas.height) { this.y = 0; }
			if (this.y < 0) { this.y = ctx.canvas.height; }
		}

		Dot.prototype.LimitSpeed = function() {
			if (this.vector.x > 1) { this.vector.x = 1; }
			if (this.vector.x < -1) { this.vector.x = -1; }
			if (this.vector.y > 1) { this.vector.y = 1; }
			if (this.vector.y < -1) { this.vector.y = -1; }
		}

		Dot.prototype.DoMovement = function () {
			this.Think();

			this.vector.x += this.neurons[0].value;
			this.vector.y += this.neurons[1].value;
			
			this.LimitSpeed();

			this.x += this.vector.x;
			this.y += this.vector.y;

			this.Wrap();
		}

		function neuron(neuronCount) {
			this.bias = (Math.random() * 3) - 1;
			this.threshold = 1;
			this.connections = [];
			this.value = (Math.random() * 3) - 1;
			this.Init();
		}

		neuron.prototype.Init = function() {
			for (let index = 0; index < 4; index++) {
				this.connections.push({
					nindex: index,
					weight: (Math.random() * 3) - 1
				});
			}
		}

		// function connection() {
		// 	this.nindex = 0;
		// 	this.weight = 0;
		// };

		function init() {
			var vectors = [];
			for (var i = 0; i <= dotCount; i++) { vectors.push(new Dot()); }

			DrawGrid(vectors);

		}

		function DrawGrid(dots) {

			for (var i = dotCount; i > 0; i--) {
				dots[i].DoMovement();
			}


			// clear screen
			pixels = ctx.createImageData(ctx.canvas.width, ctx.canvas.height);

			var index = 0;
			var dot;

			// draw
			for (var i = dotCount; i > 0; i--) {
				dot = dots[i];
				var x = Math.floor(dot.x);
				var y = Math.floor(dot.y);
				index = (x + y * ctx.canvas.width) * 4;
				if (!(x < 0 || y < 0 || x > ctx.canvas.width || y > ctx.canvas.height)) {
					pixels.data[index] = dot.color.r;
					pixels.data[index + 1] = dot.color.g;
					pixels.data[index + 2] = dot.color.b;
					pixels.data[index + 3] = dot.color.a;
				}
			}

			ctx.putImageData(pixels, 0, 0);

			setTimeout(function () { DrawGrid(dots) }, 1);
			return;
		}

		init();
	</script>
</body>

</html>